---
title: 求树上每两点的距离之和
date: 2018-11-05
tags:
 - 正则表达式
 - c++
 - 编译器

categories:
 - 树上算法

---


**给定一棵n个节点的树和n-1条边的权值，求每两点间的权值的总和。$(n \leq 1e5)$**

 - 暴力做法
 求出每两个点的$lca (O(nlogn)$预处理，$O(logn)$查询)，预处理路径前缀和后$O(1)$求得
 $n^2$数量级的点对,时间复杂度$O(n^2logn)$，TLE了。
 
 - 正解:统计每条边被经过的次数，乘以权值，求和
 
 1.每条边连接了两个联通块$a b$，一个有$k$个点，一个有$n-k$个点。
 2.因为要求的是任意两点的距离和，故每条边在$a$中的每一个点与$b$中的每一个点的路径上出现，即出现了$k*(n-k)$次，再乘以权值即可。
 3.做一遍预处理，对每个节点求出子树大小，即可在$O(n)$的时间内求出每两点的权值总和


主要代码：
```c++
int siz[maxn];
void dfs(int u, int fa)
{
    siz[u] = 1;
    for (auto v:G[u])
    {
        if (v != fa)
        {
            dfs(v, u);
            siz[u] += siz[v];
        }
    }
}

for (int i = 1; i <= n; ++i)
        ans += 1ll * siz[i] * (n - siz[i]) * w[i];
```


